###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        30/May/2015  13:28:01
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_PDB.c
#    Command line =  
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_PDB.c
#        -D LPLD_K60 -D USE_K60F12 -D ARM_MATH_CM4 -lCN
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\FLASH\List\
#        -lB
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\FLASH\List\
#        -o
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp --dlib_config
#        D:\tools\IAR\iar7_3\arm\INC\c\DLib_Config_Normal.h -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\app\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\CPU\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\common\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\LPLD\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\LPLD\HW\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\FatFs\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\FatFs\option\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\USB\common\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\USB\driver\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\USB\descriptor\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\USB\class\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\dsp\
#        -I
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\..\..\..\lib\MyDrive\
#        -On -I D:\tools\IAR\iar7_3\arm\CMSIS\Include\ -D ARM_MATH_CM4
#    List file    =  
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\FLASH\List\HW_PDB.lst
#    Object file  =  
#        D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\project\myfirst\iar\FLASH\Obj\HW_PDB.o
#
###############################################################################

D:\tools\IAR\lapulande\%5B拉普兰德K60固件库%5DLPLD_OSKinetis_V3.10\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_PDB.c
      1          /**
      2           * @file HW_PDB.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief PDB底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable5  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     23          #include "HW_PDB.h"
     24          
     25          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     26          PDB_ISR_CALLBACK PDB_ISR[1];
   \                     PDB_ISR:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     27          PDB_ISR_CALLBACK PDB_SE_ISR[1];
   \                     PDB_SE_ISR:
   \   00000000                      DS8 4
     28          
     29          //PDB时钟预分频系数乘数

   \                                 In section .rodata, align 4
     30          const uint8 pdb_sc_mults[4] = {1, 10, 20, 40};
   \                     pdb_sc_mults:
   \   00000000   0x01 0x0A          DC8 1, 10, 20, 40
   \              0x14 0x28    
     31          
     32          
     33          /*
     34           * LPLD_PDB_Init
     35           * PDBx模块通用初始化函数，初始化PDBx计数器周期、工作模式、触发源、中断等配置
     36           * 
     37           * 参数:
     38           *    pdb_init_struct--PDBx初始化结构体，
     39           *                        具体定义见PDB_InitTypeDef
     40           *
     41           * 输出:
     42           *    0--配置错误
     43           *    1--配置成功
     44           */

   \                                 In section .text, align 2, keep-with-next
     45          uint8 LPLD_PDB_Init(PDB_InitTypeDef pdb_init_struct)
     46          {
   \                     LPLD_PDB_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000006   0xED2D 0x8B02      VPUSH    {D8}
     47            uint32 us = pdb_init_struct.PDB_CounterPeriodUs
     48                      + pdb_init_struct.PDB_CounterPeriodMs*1000
     49                      + pdb_init_struct.PDB_CounterPeriodS*1000000;
   \   0000000A   0x980C             LDR      R0,[SP, #+48]
   \   0000000C   0x990D             LDR      R1,[SP, #+52]
   \   0000000E   0xF44F 0x727A      MOV      R2,#+1000
   \   00000012   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000016   0x990E             LDR      R1,[SP, #+56]
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable5_1  ;; 0xf4240
   \   0000001C   0xFB02 0x0401      MLA      R4,R2,R1,R0
     50            uint32 delayus = pdb_init_struct.PDB_DelayUs
     51                      + pdb_init_struct.PDB_DelayMs*1000
     52                      + pdb_init_struct.PDB_DelayS*1000000;
   \   00000020   0x9811             LDR      R0,[SP, #+68]
   \   00000022   0x9912             LDR      R1,[SP, #+72]
   \   00000024   0xF44F 0x727A      MOV      R2,#+1000
   \   00000028   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000002C   0x9913             LDR      R1,[SP, #+76]
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable5_1  ;; 0xf4240
   \   00000032   0xFB02 0x0501      MLA      R5,R2,R1,R0
     53            uint8 loadmode = pdb_init_struct.PDB_LoadModeSel;
   \   00000036   0xF89D 0x603C      LDRB     R6,[SP, #+60]
     54            uint8 trriger = pdb_init_struct.PDB_TriggerInputSourceSel;
   \   0000003A   0xF89D 0x703D      LDRB     R7,[SP, #+61]
     55            uint32 bus_clk = g_bus_clock/1000000;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0xf4240
   \   00000048   0xFBB0 0xF8F1      UDIV     R8,R0,R1
     56            uint8 prescaler, mult;
     57            uint32 mod;
     58            float32 temp;
     59            
     60            //参数检查
     61            ASSERT( loadmode <= LOADMODE_3 );       //加载模式选择
   \   0000004C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004E   0x2E04             CMP      R6,#+4
   \   00000050   0xDB04             BLT.N    ??LPLD_PDB_Init_0
   \   00000052   0x213D             MOVS     R1,#+61
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   00000058   0x.... 0x....      BL       assert_failed
     62            ASSERT( trriger <= TRIGGER_SOFTWARE );  //触发输入源选择
   \                     ??LPLD_PDB_Init_0: (+1)
   \   0000005C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005E   0x2F10             CMP      R7,#+16
   \   00000060   0xDB04             BLT.N    ??LPLD_PDB_Init_1
   \   00000062   0x213E             MOVS     R1,#+62
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   00000068   0x.... 0x....      BL       assert_failed
     63            
     64          /*
     65           *************************************************
     66            【LPLD注解】PDB关键系数
     67            prescaler(总线时钟预分频系数): 2^n(n:0~7)
     68            mult(prescaler的倍数): 1、10、20、40
     69            mod(计数器模数，影响计数器周期): 0~0xFFFF
     70            计数器周期 = (prescaler*mult*mod)/bus_clk
     71           *************************************************
     72           */
     73            
     74            //根据期望的计数器周期自动设定prescaler、mult和mod的值
     75            for(uint8 i=0; i<4; i++)
   \                     ??LPLD_PDB_Init_1: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??LPLD_PDB_Init_2: (+1)
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x2804             CMP      R0,#+4
   \   00000072   0xDA22             BGE.N    ??LPLD_PDB_Init_3
     76            {
     77              mult = i;
   \   00000074   0x4682             MOV      R10,R0
     78              for(uint8 j=0; j<8; j++)
   \   00000076   0x2100             MOVS     R1,#+0
   \                     ??LPLD_PDB_Init_4: (+1)
   \   00000078   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007A   0x2908             CMP      R1,#+8
   \   0000007C   0xDA13             BGE.N    ??LPLD_PDB_Init_5
     79              {
     80                prescaler = j;
   \   0000007E   0x4689             MOV      R9,R1
     81                mod = (bus_clk*us)/((1<<j)*pdb_sc_mults[i]);
   \   00000080   0xFB04 0xF208      MUL      R2,R4,R8
   \   00000084   0x2301             MOVS     R3,#+1
   \   00000086   0x408B             LSLS     R3,R3,R1
   \   00000088   0x.... 0x....      LDR.W    R12,??DataTable5_4
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0xF810 0xC00C      LDRB     R12,[R0, R12]
   \   00000092   0xFB0C 0xF303      MUL      R3,R12,R3
   \   00000096   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   0000009A   0x4693             MOV      R11,R2
     82                if(mod <= 0xFFFFu)
   \   0000009C   0xF5BB 0x3F80      CMP      R11,#+65536
   \   000000A0   0xD301             BCC.N    ??LPLD_PDB_Init_5
     83                  break;
     84              }
   \                     ??LPLD_PDB_Init_6: (+1)
   \   000000A2   0x1C49             ADDS     R1,R1,#+1
   \   000000A4   0xE7E8             B.N      ??LPLD_PDB_Init_4
     85              if(mod <= 0xFFFFu)
   \                     ??LPLD_PDB_Init_5: (+1)
   \   000000A6   0xF5BB 0x3F80      CMP      R11,#+65536
   \   000000AA   0xD306             BCC.N    ??LPLD_PDB_Init_3
     86                break;
     87              else if(i == 3)
   \                     ??LPLD_PDB_Init_7: (+1)
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0x2803             CMP      R0,#+3
   \   000000B0   0xD101             BNE.N    ??LPLD_PDB_Init_8
     88                return 0;         //PDB计数周期设置的过小，计算错误
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xE0B5             B.N      ??LPLD_PDB_Init_9
     89            }
   \                     ??LPLD_PDB_Init_8: (+1)
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0xE7D9             B.N      ??LPLD_PDB_Init_2
     90            
     91            //使能PDB时钟
     92            SIM->SCGC6 |= SIM_SCGC6_PDB_MASK;
   \                     ??LPLD_PDB_Init_3: (+1)
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable5_5  ;; 0x4004803c
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable5_5  ;; 0x4004803c
   \   000000C8   0x6008             STR      R0,[R1, #+0]
     93            
     94            //初始化SC寄存器
     95            PDB0->SC = 0x00;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable5_6  ;; 0x40036000
   \   000000D0   0x6008             STR      R0,[R1, #+0]
     96            //使能PDB
     97            PDB0->SC |= PDB_SC_PDBEN_MASK;
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable5_6  ;; 0x40036000
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable5_6  ;; 0x40036000
   \   000000E0   0x6008             STR      R0,[R1, #+0]
     98            PDB0->SC |= PDB_SC_MULT(mult);
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable5_6  ;; 0x40036000
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000EC   0xEA5F 0x018A      LSLS     R1,R10,#+2
   \   000000F0   0xF011 0x010C      ANDS     R1,R1,#0xC
   \   000000F4   0x4308             ORRS     R0,R1,R0
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable5_6  ;; 0x40036000
   \   000000FA   0x6008             STR      R0,[R1, #+0]
     99            PDB0->SC |= PDB_SC_PRESCALER(prescaler);
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable5_6  ;; 0x40036000
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000106   0xEA5F 0x3109      LSLS     R1,R9,#+12
   \   0000010A   0xF411 0x41E0      ANDS     R1,R1,#0x7000
   \   0000010E   0x4308             ORRS     R0,R1,R0
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable5_6  ;; 0x40036000
   \   00000114   0x6008             STR      R0,[R1, #+0]
    100            //配置MOD、IDLY、CHnDLYm、INTx和POyDLY寄存器的加载模式
    101            PDB0->SC |= PDB_SC_LDMOD(loadmode); 
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable5_6  ;; 0x40036000
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000011E   0x04B1             LSLS     R1,R6,#+18
   \   00000120   0xF411 0x2140      ANDS     R1,R1,#0xC0000
   \   00000124   0x4308             ORRS     R0,R1,R0
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable5_6  ;; 0x40036000
   \   0000012A   0x6008             STR      R0,[R1, #+0]
    102            //配置触发输入源
    103            PDB0->SC |= PDB_SC_TRGSEL(trriger);
   \   0000012C   0x.... 0x....      LDR.W    R0,??DataTable5_6  ;; 0x40036000
   \   00000130   0x6800             LDR      R0,[R0, #+0]
   \   00000132   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000134   0x0239             LSLS     R1,R7,#+8
   \   00000136   0xF411 0x6170      ANDS     R1,R1,#0xF00
   \   0000013A   0x4308             ORRS     R0,R1,R0
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable5_6  ;; 0x40036000
   \   00000140   0x6008             STR      R0,[R1, #+0]
    104            
    105            //是否使能连续模式
    106            if(pdb_init_struct.PDB_ContinuousModeEnable == TRUE)
   \   00000142   0xF89D 0x003E      LDRB     R0,[SP, #+62]
   \   00000146   0x2801             CMP      R0,#+1
   \   00000148   0xD106             BNE.N    ??LPLD_PDB_Init_10
    107              PDB0->SC |= PDB_SC_CONT_MASK;
   \   0000014A   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000152   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   00000154   0x6008             STR      R0,[R1, #+0]
   \   00000156   0xE005             B.N      ??LPLD_PDB_Init_11
    108            else
    109              PDB0->SC &= ~(PDB_SC_CONT_MASK);
   \                     ??LPLD_PDB_Init_10: (+1)
   \   00000158   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   0000015A   0x6800             LDR      R0,[R0, #+0]
   \   0000015C   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000160   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   00000162   0x6008             STR      R0,[R1, #+0]
    110            
    111            //是否使能DMA
    112            if(pdb_init_struct.PDB_DmaEnable == TRUE)
   \                     ??LPLD_PDB_Init_11: (+1)
   \   00000164   0xF89D 0x003F      LDRB     R0,[SP, #+63]
   \   00000168   0x2801             CMP      R0,#+1
   \   0000016A   0xD106             BNE.N    ??LPLD_PDB_Init_12
    113              PDB0->SC |= PDB_SC_DMAEN_MASK;
   \   0000016C   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   0000016E   0x6800             LDR      R0,[R0, #+0]
   \   00000170   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000174   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   00000176   0x6008             STR      R0,[R1, #+0]
   \   00000178   0xE005             B.N      ??LPLD_PDB_Init_13
    114            else
    115              PDB0->SC &= ~(PDB_SC_DMAEN_MASK);
   \                     ??LPLD_PDB_Init_12: (+1)
   \   0000017A   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   0000017C   0x6800             LDR      R0,[R0, #+0]
   \   0000017E   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000182   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   00000184   0x6008             STR      R0,[R1, #+0]
    116            
    117            if(pdb_init_struct.PDB_Isr != NULL)
   \                     ??LPLD_PDB_Init_13: (+1)
   \   00000186   0x9814             LDR      R0,[SP, #+80]
   \   00000188   0x2800             CMP      R0,#+0
   \   0000018A   0xD013             BEQ.N    ??LPLD_PDB_Init_14
    118            {
    119              PDB_ISR[0] = pdb_init_struct.PDB_Isr;
   \   0000018C   0x9814             LDR      R0,[SP, #+80]
   \   0000018E   0x....             LDR.N    R1,??DataTable5_7
   \   00000190   0x6008             STR      R0,[R1, #+0]
    120              //是否使能PDB中断
    121              if(pdb_init_struct.PDB_IntEnable == TRUE)
   \   00000192   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \   00000196   0x2801             CMP      R0,#+1
   \   00000198   0xD106             BNE.N    ??LPLD_PDB_Init_15
    122                PDB0->SC |= PDB_SC_PDBIE_MASK;
   \   0000019A   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   0000019C   0x6800             LDR      R0,[R0, #+0]
   \   0000019E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000001A2   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   000001A4   0x6008             STR      R0,[R1, #+0]
   \   000001A6   0xE005             B.N      ??LPLD_PDB_Init_14
    123              else
    124                PDB0->SC &= ~(PDB_SC_PDBIE_MASK);
   \                     ??LPLD_PDB_Init_15: (+1)
   \   000001A8   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0xF030 0x0020      BICS     R0,R0,#0x20
   \   000001B0   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   000001B2   0x6008             STR      R0,[R1, #+0]
    125            }
    126            
    127            if(pdb_init_struct.PDB_SeqErrIsr != NULL)
   \                     ??LPLD_PDB_Init_14: (+1)
   \   000001B4   0x9815             LDR      R0,[SP, #+84]
   \   000001B6   0x2800             CMP      R0,#+0
   \   000001B8   0xD013             BEQ.N    ??LPLD_PDB_Init_16
    128            {
    129              PDB_SE_ISR[0] = pdb_init_struct.PDB_SeqErrIsr;
   \   000001BA   0x9815             LDR      R0,[SP, #+84]
   \   000001BC   0x....             LDR.N    R1,??DataTable5_8
   \   000001BE   0x6008             STR      R0,[R1, #+0]
    130              //是否使能PDB序列错误中断
    131              if(pdb_init_struct.PDB_SeqErrIntEnable == TRUE)
   \   000001C0   0xF89D 0x0041      LDRB     R0,[SP, #+65]
   \   000001C4   0x2801             CMP      R0,#+1
   \   000001C6   0xD106             BNE.N    ??LPLD_PDB_Init_17
    132                PDB0->SC |= PDB_SC_PDBEIE_MASK;
   \   000001C8   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   000001CA   0x6800             LDR      R0,[R0, #+0]
   \   000001CC   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   000001D0   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   000001D2   0x6008             STR      R0,[R1, #+0]
   \   000001D4   0xE005             B.N      ??LPLD_PDB_Init_16
    133              else
    134                PDB0->SC &= ~(PDB_SC_PDBEIE_MASK);
   \                     ??LPLD_PDB_Init_17: (+1)
   \   000001D6   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   000001D8   0x6800             LDR      R0,[R0, #+0]
   \   000001DA   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   000001DE   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   000001E0   0x6008             STR      R0,[R1, #+0]
    135            }
    136            
    137            //设置PDB中断延时时间
    138            if( delayus <= us )
   \                     ??LPLD_PDB_Init_16: (+1)
   \   000001E2   0x42AC             CMP      R4,R5
   \   000001E4   0xD316             BCC.N    ??LPLD_PDB_Init_18
    139            {
    140              temp = (float32)mod/(float32)us;
   \   000001E6   0xEE00 0xBA10      VMOV     S0,R11
   \   000001EA   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000001EE   0xEE00 0x4A90      VMOV     S1,R4
   \   000001F2   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   000001F6   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000001FA   0xEEB0 0x8A40      VMOV.F32 S16,S0
    141              PDB0->IDLY = (uint32)(delayus*temp);
   \   000001FE   0xEE00 0x5A10      VMOV     S0,R5
   \   00000202   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000206   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   0000020A   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   0000020E   0x....             LDR.N    R0,??DataTable5_9  ;; 0x4003600c
   \   00000210   0xED80 0x0A00      VSTR     S0,[R0, #0]
    142            }
    143            
    144            //加载值
    145            PDB0->SC |= PDB_SC_LDOK_MASK;
   \                     ??LPLD_PDB_Init_18: (+1)
   \   00000214   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   00000216   0x6800             LDR      R0,[R0, #+0]
   \   00000218   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000021C   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   0000021E   0x6008             STR      R0,[R1, #+0]
    146            
    147            return 1;
   \   00000220   0x2001             MOVS     R0,#+1
   \                     ??LPLD_PDB_Init_9: (+1)
   \   00000222   0xECBD 0x8B02      VPOP     {D8}
   \   00000226   0xE8BD 0x0FF2      POP      {R1,R4-R11}
   \   0000022A   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    148          }
    149          
    150          /*
    151           * LPLD_PDB_Deinit
    152           * PDBx模块反初始化函数，禁用PDBx所有功能
    153           * 
    154           * 参数:
    155           *    无
    156           *
    157           * 输出:
    158           *    无
    159           */

   \                                 In section .text, align 2, keep-with-next
    160          void LPLD_PDB_Deinit(void)
    161          {
   \                     LPLD_PDB_Deinit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    162           
    163            PDB0->CH[0].C1 = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable5_10  ;; 0x40036010
   \   00000006   0x6008             STR      R0,[R1, #+0]
    164            PDB0->CH[1].C1 = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable5_11  ;; 0x40036038
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    165            
    166            PDB0->DAC[0].INTC = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable5_12  ;; 0x40036150
   \   00000012   0x6008             STR      R0,[R1, #+0]
    167            PDB0->DAC[1].INTC = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable5_13  ;; 0x40036158
   \   00000018   0x6008             STR      R0,[R1, #+0]
    168            
    169            PDB0->SC = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    170            
    171            //禁用PDB时钟
    172            SIM->SCGC6 &= ~(SIM_SCGC6_PDB_MASK);
   \   00000020   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4004803c
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF430 0x0080      BICS     R0,R0,#0x400000
   \   00000028   0x....             LDR.N    R1,??DataTable5_5  ;; 0x4004803c
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    173            
    174            disable_irq(PDB0_IRQn);
   \   0000002C   0x2048             MOVS     R0,#+72
   \   0000002E   0x.... 0x....      BL       NVIC_DisableIRQ
    175          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    176          
    177          
    178          /*
    179           * LPLD_PDB_AdcTriggerCfg
    180           * PDBx触发ADCx模块配置函数
    181           * 
    182           * 参数:
    183           *    adcx--ADCx模块号
    184           *      |__ADC0          --ADC0
    185           *      |__ADC1          --ADC1
    186           *    cfg--ADCx预触发功能配置，可多个值合并配置(eg. cfg=PRETRIG_EN_A|PRETRIG_DLY_A;)
    187           *      ADCx A组配置
    188           *      |__PRETRIG_EN_A  --使能ADCx的A组预触发功能
    189           *      |__PRETRIG_DLY_A --使能ADCx的A组延时输出预触发功能
    190           *      |__PRETRIG_BB_A  --使能ADCx的A组“Back to Back”模式
    191           *      ADCx B组配置
    192           *      |__PRETRIG_EN_B  --使能ADCx的B组预触发功能
    193           *      |__PRETRIG_DLY_B --使能ADCx的B组延时输出预触发功能
    194           *      |__PRETRIG_BB_B  --使能ADCx的B组“Back to Back”模式
    195           *    delay--ADCx A或B组的延时输出预触发时间，单位us
    196           *      |__0~0xFFFF      --0~4095us
    197           *
    198           * 输出:
    199           *    0--配置错误
    200           *    1--配置成功
    201           */

   \                                 In section .text, align 2, keep-with-next
    202          uint8 LPLD_PDB_AdcTriggerCfg(ADC_Type *adcx, uint32 cfg, uint16 delay)
    203          {
   \                     LPLD_PDB_AdcTriggerCfg: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0003             MOVS     R3,R0
    204            uint8 n,m;
    205            uint8 prescaler, mult;
    206            uint32 bus_clk = g_bus_clock/1000000;
   \   00000006   0x....             LDR.N    R0,??DataTable5_2
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x.... 0x....      LDR.W    R12,??DataTable5_1  ;; 0xf4240
   \   0000000E   0xFBB0 0xFCFC      UDIV     R12,R0,R12
    207          
    208            if(adcx == ADC0)
   \   00000012   0x....             LDR.N    R0,??DataTable5_14  ;; 0x4003b000
   \   00000014   0x4283             CMP      R3,R0
   \   00000016   0xD102             BNE.N    ??LPLD_PDB_AdcTriggerCfg_0
    209              n = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0004             MOVS     R4,R0
   \   0000001C   0xE013             B.N      ??LPLD_PDB_AdcTriggerCfg_1
    210            else if(adcx == ADC1)
   \                     ??LPLD_PDB_AdcTriggerCfg_0: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable5_15  ;; 0x400bb000
   \   00000020   0x4283             CMP      R3,R0
   \   00000022   0xD102             BNE.N    ??LPLD_PDB_AdcTriggerCfg_2
    211              n = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x0004             MOVS     R4,R0
   \   00000028   0xE00D             B.N      ??LPLD_PDB_AdcTriggerCfg_1
    212          #if defined(CPU_MK60F12) || defined(CPU_MK60F15)
    213            else if(adcx == ADC2)
   \                     ??LPLD_PDB_AdcTriggerCfg_2: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable5_16  ;; 0x4003c000
   \   0000002C   0x4283             CMP      R3,R0
   \   0000002E   0xD102             BNE.N    ??LPLD_PDB_AdcTriggerCfg_3
    214              n = 2;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0x0004             MOVS     R4,R0
   \   00000034   0xE007             B.N      ??LPLD_PDB_AdcTriggerCfg_1
    215            else if(adcx == ADC3)
   \                     ??LPLD_PDB_AdcTriggerCfg_3: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable5_17  ;; 0x400bc000
   \   00000038   0x4283             CMP      R3,R0
   \   0000003A   0xD102             BNE.N    ??LPLD_PDB_AdcTriggerCfg_4
    216              n = 3;  
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x0004             MOVS     R4,R0
   \   00000040   0xE001             B.N      ??LPLD_PDB_AdcTriggerCfg_1
    217          #endif 
    218            else
    219              return 0;
   \                     ??LPLD_PDB_AdcTriggerCfg_4: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE04F             B.N      ??LPLD_PDB_AdcTriggerCfg_5
    220              
    221            if(cfg & 0x01)
   \                     ??LPLD_PDB_AdcTriggerCfg_1: (+1)
   \   00000046   0x07C8             LSLS     R0,R1,#+31
   \   00000048   0xD502             BPL.N    ??LPLD_PDB_AdcTriggerCfg_6
    222              m = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x0005             MOVS     R5,R0
   \   0000004E   0xE006             B.N      ??LPLD_PDB_AdcTriggerCfg_7
    223            else if(cfg & 0x02)
   \                     ??LPLD_PDB_AdcTriggerCfg_6: (+1)
   \   00000050   0x0788             LSLS     R0,R1,#+30
   \   00000052   0xD502             BPL.N    ??LPLD_PDB_AdcTriggerCfg_8
    224              m = 1;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x0005             MOVS     R5,R0
   \   00000058   0xE001             B.N      ??LPLD_PDB_AdcTriggerCfg_7
    225            else
    226              return 0;
   \                     ??LPLD_PDB_AdcTriggerCfg_8: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xE043             B.N      ??LPLD_PDB_AdcTriggerCfg_5
    227            
    228            prescaler = 1<<((PDB0->SC & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT);
   \                     ??LPLD_PDB_AdcTriggerCfg_7: (+1)
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x.... 0x....      LDR.W    LR,??DataTable5_6  ;; 0x40036000
   \   00000064   0xF8DE 0xE000      LDR      LR,[LR, #+0]
   \   00000068   0xEA5F 0x3E1E      LSRS     LR,LR,#+12
   \   0000006C   0xF01E 0x0E07      ANDS     LR,LR,#0x7
   \   00000070   0xFA10 0xF00E      LSLS     R0,R0,LR
   \   00000074   0x0006             MOVS     R6,R0
    229            mult = pdb_sc_mults[(PDB0->SC & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT];
   \   00000076   0x....             LDR.N    R0,??DataTable5_4
   \   00000078   0x.... 0x....      LDR.W    LR,??DataTable5_6  ;; 0x40036000
   \   0000007C   0xF8DE 0xE000      LDR      LR,[LR, #+0]
   \   00000080   0xF3CE 0x0E81      UBFX     LR,LR,#+2,#+2
   \   00000084   0xF81E 0x0000      LDRB     R0,[LR, R0]
   \   00000088   0x0007             MOVS     R7,R0
    230            
    231            PDB0->CH[n].C1 |= cfg;        //根据参数配置BB模式、选择预触发输出、使能预触发
   \   0000008A   0x....             LDR.N    R0,??DataTable5_10  ;; 0x40036010
   \   0000008C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008E   0xF05F 0x0E28      MOVS     LR,#+40
   \   00000092   0xFB0E 0x0004      MLA      R0,LR,R4,R0
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x4308             ORRS     R0,R1,R0
   \   0000009A   0x.... 0x....      LDR.W    LR,??DataTable5_10  ;; 0x40036010
   \   0000009E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A0   0xF05F 0x0828      MOVS     R8,#+40
   \   000000A4   0xFB08 0xEE04      MLA      LR,R8,R4,LR
   \   000000A8   0xF8CE 0x0000      STR      R0,[LR, #+0]
    232            PDB0->CH[n].DLY[m] = (bus_clk * delay)/(prescaler * mult);    //配置ADCn的m组预触发延时值
   \   000000AC   0x....             LDR.N    R0,??DataTable5_10  ;; 0x40036010
   \   000000AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B0   0xF05F 0x0E28      MOVS     LR,#+40
   \   000000B4   0xFB0E 0x0004      MLA      R0,LR,R4,R0
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0xEB10 0x0085      ADDS     R0,R0,R5, LSL #+2
   \   000000BE   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000C0   0xFB02 0xFE0C      MUL      LR,R2,R12
   \   000000C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000C8   0xFB07 0xF806      MUL      R8,R7,R6
   \   000000CC   0xFBBE 0xFEF8      UDIV     LR,LR,R8
   \   000000D0   0xF8C0 0xE008      STR      LR,[R0, #+8]
    233            
    234            PDB0->SC |= PDB_SC_LDOK_MASK; //加载值
   \   000000D4   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000DC   0x.... 0x....      LDR.W    LR,??DataTable5_6  ;; 0x40036000
   \   000000E0   0xF8CE 0x0000      STR      R0,[LR, #+0]
    235            
    236            return 1;
   \   000000E4   0x2001             MOVS     R0,#+1
   \                     ??LPLD_PDB_AdcTriggerCfg_5: (+1)
   \   000000E6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    237          }
    238          
    239          /*
    240           * LPLD_PDB_DacTriggerCfg
    241           * PDBx触发DACx模块配置函数
    242           * 
    243           * 参数:
    244           *    dacx--DACx模块号
    245           *      |__DAC0          --DAC0
    246           *      |__DAC1          --DAC1
    247           *    cfg--DACx触发功能配置
    248           *      |__EXT_TRIG_EN   --使能外部触发
    249           *      |__EINT_TRIG_EN  --使能内部间隔触发
    250           *    int_delay--DACx间隔触发时间，单位us
    251           *      |__0~0xFFFF      --0~4095us
    252           *
    253           * 输出:
    254           *    0--配置错误
    255           *    1--配置成功
    256           */

   \                                 In section .text, align 2, keep-with-next
    257          uint8 LPLD_PDB_DacTriggerCfg(DAC_Type *dacx, uint32 cfg, uint16 int_delay)
    258          {
   \                     LPLD_PDB_DacTriggerCfg: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
    259            uint8 n;
    260            uint8 prescaler, mult;
    261            uint32 bus_clk = g_bus_clock/1000000;
   \   00000004   0x....             LDR.N    R0,??DataTable5_2
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R7,??DataTable5_1  ;; 0xf4240
   \   0000000A   0xFBB0 0xF7F7      UDIV     R7,R0,R7
    262            
    263            if(dacx == DAC0)
   \   0000000E   0x....             LDR.N    R0,??DataTable5_18  ;; 0x400cc000
   \   00000010   0x4283             CMP      R3,R0
   \   00000012   0xD102             BNE.N    ??LPLD_PDB_DacTriggerCfg_0
    264              n = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0004             MOVS     R4,R0
   \   00000018   0xE007             B.N      ??LPLD_PDB_DacTriggerCfg_1
    265            else if(dacx == DAC1)
   \                     ??LPLD_PDB_DacTriggerCfg_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable5_19  ;; 0x400cd000
   \   0000001C   0x4283             CMP      R3,R0
   \   0000001E   0xD102             BNE.N    ??LPLD_PDB_DacTriggerCfg_2
    266              n = 1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x0004             MOVS     R4,R0
   \   00000024   0xE001             B.N      ??LPLD_PDB_DacTriggerCfg_1
    267            else
    268              return 0;
   \                     ??LPLD_PDB_DacTriggerCfg_2: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE038             B.N      ??LPLD_PDB_DacTriggerCfg_3
    269            
    270            prescaler = 1<<((PDB0->SC & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT);
   \                     ??LPLD_PDB_DacTriggerCfg_1: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x.... 0x....      LDR.W    R12,??DataTable5_6  ;; 0x40036000
   \   00000030   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000034   0xEA5F 0x3C1C      LSRS     R12,R12,#+12
   \   00000038   0xF01C 0x0C07      ANDS     R12,R12,#0x7
   \   0000003C   0xFA10 0xF00C      LSLS     R0,R0,R12
   \   00000040   0x0005             MOVS     R5,R0
    271            mult = pdb_sc_mults[(PDB0->SC & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT];
   \   00000042   0x....             LDR.N    R0,??DataTable5_4
   \   00000044   0x.... 0x....      LDR.W    R12,??DataTable5_6  ;; 0x40036000
   \   00000048   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   0000004C   0xF3CC 0x0C81      UBFX     R12,R12,#+2,#+2
   \   00000050   0xF81C 0x0000      LDRB     R0,[R12, R0]
   \   00000054   0x0006             MOVS     R6,R0
    272            
    273            PDB0->DAC[n].INTC |= cfg;     //配置使能外部触发或者内部间隔触发
   \   00000056   0x....             LDR.N    R0,??DataTable5_12  ;; 0x40036150
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0xF850 0x0034      LDR      R0,[R0, R4, LSL #+3]
   \   0000005E   0x4308             ORRS     R0,R1,R0
   \   00000060   0x.... 0x....      LDR.W    R12,??DataTable5_12  ;; 0x40036150
   \   00000064   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000066   0xF84C 0x0034      STR      R0,[R12, R4, LSL #+3]
    274            PDB0->DAC[n].INT = (bus_clk * int_delay)/(prescaler * mult);    //配置DACn的间隔触发时间
   \   0000006A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000006C   0xFB02 0xF007      MUL      R0,R2,R7
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0xFB06 0xFC05      MUL      R12,R6,R5
   \   00000078   0xFBB0 0xF0FC      UDIV     R0,R0,R12
   \   0000007C   0x.... 0x....      LDR.W    R12,??DataTable5_12  ;; 0x40036150
   \   00000080   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   0xEB1C 0x0CC4      ADDS     R12,R12,R4, LSL #+3
   \   00000086   0xF8CC 0x0004      STR      R0,[R12, #+4]
    275            
    276            PDB0->SC |= PDB_SC_LDOK_MASK; //加载值
   \   0000008A   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000092   0x.... 0x....      LDR.W    R12,??DataTable5_6  ;; 0x40036000
   \   00000096   0xF8CC 0x0000      STR      R0,[R12, #+0]
    277            
    278            return 1;
   \   0000009A   0x2001             MOVS     R0,#+1
   \                     ??LPLD_PDB_DacTriggerCfg_3: (+1)
   \   0000009C   0xBCF0             POP      {R4-R7}
   \   0000009E   0x4770             BX       LR               ;; return
    279          }
    280          
    281          /*
    282           * PDB中断处理函数
    283           * 与启动文件startup_K60.s中的中断向量表关联
    284           * 用户无需修改，程序自动进入对应通道中断函数
    285           */

   \                                 In section .text, align 2, keep-with-next
    286          void PDB_IRQHandler(void)
    287          {
   \                     PDB_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    288          #if (UCOS_II > 0u)
    289            OS_CPU_SR  cpu_sr = 0u;
    290            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    291            OSIntEnter();
    292            OS_EXIT_CRITICAL();
    293          #endif
    294            
    295            //是否为PDB中断
    296            if((PDB0->SC & PDB_SC_PDBIF_MASK) && (PDB0->SC & PDB_SC_PDBIE_MASK))
   \   00000002   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0640             LSLS     R0,R0,#+25
   \   00000008   0xD50C             BPL.N    ??PDB_IRQHandler_0
   \   0000000A   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0680             LSLS     R0,R0,#+26
   \   00000010   0xD508             BPL.N    ??PDB_IRQHandler_0
    297            {
    298              //调用用户自定义中断服务
    299              PDB_ISR[0]();  
   \   00000012   0x....             LDR.N    R0,??DataTable5_7
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x4780             BLX      R0
    300              //清除中断标志位  
    301              PDB0->SC &= ~PDB_SC_PDBIF_MASK;
   \   00000018   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF030 0x0040      BICS     R0,R0,#0x40
   \   00000020   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40036000
   \   00000022   0x6008             STR      R0,[R1, #+0]
    302            }
    303            
    304            //是否为PDB序列错误中断 CH0
    305            if((PDB0->CH[0].S & PDB_S_ERR(1)) && (PDB0->SC & PDB_SC_PDBEIE_MASK))
   \                     ??PDB_IRQHandler_0: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable5_20  ;; 0x40036014
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD50C             BPL.N    ??PDB_IRQHandler_1
   \   0000002C   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0380             LSLS     R0,R0,#+14
   \   00000032   0xD508             BPL.N    ??PDB_IRQHandler_1
    306            {
    307              //调用用户自定义中断服务
    308              PDB_SE_ISR[0]();  
   \   00000034   0x....             LDR.N    R0,??DataTable5_8
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x4780             BLX      R0
    309              PDB0->CH[0].S |= PDB_S_ERR(1);
   \   0000003A   0x....             LDR.N    R0,??DataTable5_20  ;; 0x40036014
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000042   0x....             LDR.N    R1,??DataTable5_20  ;; 0x40036014
   \   00000044   0x6008             STR      R0,[R1, #+0]
    310            }
    311            
    312            //是否为PDB序列错误中断 CH1
    313            if((PDB0->CH[1].S & PDB_S_ERR(2)) && (PDB0->SC & PDB_SC_PDBEIE_MASK))
   \                     ??PDB_IRQHandler_1: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable5_21  ;; 0x4003603c
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x0780             LSLS     R0,R0,#+30
   \   0000004C   0xD50C             BPL.N    ??PDB_IRQHandler_2
   \   0000004E   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40036000
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x0380             LSLS     R0,R0,#+14
   \   00000054   0xD508             BPL.N    ??PDB_IRQHandler_2
    314            {
    315              //调用用户自定义中断服务
    316              PDB_SE_ISR[0]();  
   \   00000056   0x....             LDR.N    R0,??DataTable5_8
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x4780             BLX      R0
    317              PDB0->CH[1].S |= PDB_S_ERR(2);
   \   0000005C   0x....             LDR.N    R0,??DataTable5_21  ;; 0x4003603c
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000064   0x....             LDR.N    R1,??DataTable5_21  ;; 0x4003603c
   \   00000066   0x6008             STR      R0,[R1, #+0]
    318            }
    319            
    320          #if (UCOS_II > 0u)
    321            OSIntExit();          //告知系统此时即将离开中断服务子函数
    322          #endif
    323          }
   \                     ??PDB_IRQHandler_2: (+1)
   \   00000068   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     g_bus_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     pdb_sc_mults

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x40036000         DC32     0x40036000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     PDB_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     PDB_SE_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x4003600C         DC32     0x4003600c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x40036010         DC32     0x40036010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x40036038         DC32     0x40036038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x40036150         DC32     0x40036150

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x40036158         DC32     0x40036158

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x400BB000         DC32     0x400bb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x4003C000         DC32     0x4003c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x400BC000         DC32     0x400bc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x400CC000         DC32     0x400cc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x400CD000         DC32     0x400cd000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x40036014         DC32     0x40036014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0x4003603C         DC32     0x4003603c

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 74H, 6FH, 6FH, 6CH, 73H
   \              0x5C 0x74    
   \              0x6F 0x6F    
   \              0x6C 0x73    
   \   00000008   0x5C 0x49          DC8 5CH, 49H, 41H, 52H, 5CH, 6CH, 61H, 70H
   \              0x41 0x52    
   \              0x5C 0x6C    
   \              0x61 0x70    
   \   00000010   0x75 0x6C          DC8 75H, 6CH, 61H, 6EH, 64H, 65H, 5CH, 25H
   \              0x61 0x6E    
   \              0x64 0x65    
   \              0x5C 0x25    
   \   00000018   0x35 0x42          DC8 35H, 42H, 0C0H, 0ADH, 0C6H, 0D5H, 0C0H, 0BCH
   \              0xC0 0xAD    
   \              0xC6 0xD5    
   \              0xC0 0xBC    
   \   00000020   0xB5 0xC2          DC8 0B5H, 0C2H, 4BH, 36H, 30H, 0B9H, 0CCH, 0BCH
   \              0x4B 0x36    
   \              0x30 0xB9    
   \              0xCC 0xBC    
   \   00000028   0xFE 0xBF          DC8 0FEH, 0BFH, 0E2H, 25H, 35H, 44H, 4CH, 50H
   \              0xE2 0x25    
   \              0x35 0x44    
   \              0x4C 0x50    
   \   00000030   0x4C 0x44          DC8 4CH, 44H, 5FH, 4FH, 53H, 4BH, 69H, 6EH
   \              0x5F 0x4F    
   \              0x53 0x4B    
   \              0x69 0x6E    
   \   00000038   0x65 0x74          DC8 65H, 74H, 69H, 73H, 5FH, 56H, 33H, 2EH
   \              0x69 0x73    
   \              0x5F 0x56    
   \              0x33 0x2E    
   \   00000040   0x31 0x30          DC8 31H, 30H, 5CH, 4CH, 50H, 4CH, 44H, 5FH
   \              0x5C 0x4C    
   \              0x50 0x4C    
   \              0x44 0x5F    
   \   00000048   0x4F 0x53          DC8 4FH, 53H, 4BH, 69H, 6EH, 65H, 74H, 69H
   \              0x4B 0x69    
   \              0x6E 0x65    
   \              0x74 0x69    
   \   00000050   0x73 0x5F          DC8 73H, 5FH, 56H, 33H, 5CH, 6CH, 69H, 62H
   \              0x56 0x33    
   \              0x5C 0x6C    
   \              0x69 0x62    
   \   00000058   0x5C 0x4C          DC8 5CH, 4CH, 50H, 4CH, 44H, 5CH, 48H, 57H
   \              0x50 0x4C    
   \              0x44 0x5C    
   \              0x48 0x57    
   \   00000060   0x5C 0x48          DC8 5CH, 48H, 57H, 5FH, 50H, 44H, 42H, 2EH
   \              0x57 0x5F    
   \              0x50 0x44    
   \              0x42 0x2E    
   \   00000068   0x63 0x00          DC8 63H, 0
   \   0000006A   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   LPLD_PDB_AdcTriggerCfg
      16   LPLD_PDB_DacTriggerCfg
       8   LPLD_PDB_Deinit
         8   -> NVIC_DisableIRQ
      64   LPLD_PDB_Init
        64   -> assert_failed
       0   NVIC_DisableIRQ
       8   PDB_IRQHandler
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
     108  ?_0
     234  LPLD_PDB_AdcTriggerCfg
     160  LPLD_PDB_DacTriggerCfg
      52  LPLD_PDB_Deinit
     558  LPLD_PDB_Init
      22  NVIC_DisableIRQ
     106  PDB_IRQHandler
       4  PDB_ISR
       4  PDB_SE_ISR
       4  pdb_sc_mults

 
     8 bytes in section .bss
   112 bytes in section .rodata
 1 220 bytes in section .text
 
 1 220 bytes of CODE  memory
   112 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
